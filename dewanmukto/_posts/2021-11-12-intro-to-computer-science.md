---
layout: post
title : Introduction to Computer Science (with Python)
author: Dewan Mukto
date: 2021-11-12
toc: false
---

> *This course is an elaboration on what I myself know so far, and also from what I have been taught at university. I have observed that most teachers do not know how to  \"teach \" in the most appropriate method. They usually teach from **their** perspective, directed towards mature students. They **assume** that we already know these terms. But that is where it goes wrong! The best way of teaching is not by assuming that you are teaching a group of adults; rather, teachers should teach it as if they would teach young children. Thus, this course is a form of revolution in the entire world \'s education system. I shall try to redefine how schools, colleges and universities operate across the globe. Wish me luck, everyone.*

## Introduction
Before we begin, let us contemplate (think about) the subject. **Computer science**, yes. You might be thinking that this is all about computers, chips, programming. Lots and lots of programming. But, I would like to tell you that **No**, it is not like that.

Interestingly, the so-called study of  \"computer science \" had existed throughout history, before computers were even invented! Shocking, right?

So, what IS computer science? The accurate answer would be  \'the study of algorithms, problem-solving, logic and how we implement them into machines \', i.e. computers.

Now, if you are not familiar with the term **algorithm**, here is a quick explanation :

Algorithms are steps taken to solve problems. Does not have to be written in code. For example, you would want to fry an egg. What should you do? You would normally find or create a list of steps.

1. Crack the egg
2. Pour the yolk and liquid into a bowl
3. Add 1 tea spoon of salt and pepper
4. Pour mixture onto a pan
5. Heat for 10-20 minutes
6. Serve and eat

There you have it! That, my friend, is an algorithm! And you thought algorithms would be more to do with technology, eh? Have a quick smile and take a mental note not to be fooled by the subject \'s title  \"computer science \". An alternate (and more fitting) name for this subject would be  \"problem-solving \". Although that last statement was just my personal opinion.

Thus, you may have understood that

> An algorithm is simply a step-by-step process for completing a particular task...

You already understood that part. But wait! There is more!

> ...and it needs to be able to guarantee a result that will be finite...

Makes sense because you would obviously want proper algorithms that can be useful in the real world, for real life circumstances.

> ...and it must complete it within a finite timeframe.

Bingo. That is the  \"formal \" definition of what an algorithm is, broken down into bite-sized chunks.

But algorithms on their own are not very efficient ways to solve a problem, are they? Ofcourse not! Which is why we need computers!

And computers, as you might know, require certain instructions in order to work. I mean, they are machines after all. Machine learning, artificial intelligence may prove otherwise, but those topics will be covered in another course. So what do we call these  \"instructions \" ? **Programs!** Because they are created via  \"programming \".

Programs are computerized (digital) versions of a set of instructions to solve a problem or to accomplish a task. They are expressed in the form of programming languages. Just like we humans struggle to understand foreign languages or languages which we are not familiar with, computers are similar! They do not understand English nor any other  \"human \" languages (yet)[^1]. So what now?

Simple : Computers *do* understand a few specific languages. They \'re called programming languages. And just like we have  \"grammar \" in English (or any other language), programming languages have  \"syntaxes \". So you can say **syntax** is a fancy way of referring to  \"grammar for computers \".

Just as there are several types of languages around the world, e.g. English, French, Bangla, Arabic, Hindi, Latin, etc., there are also several  \"programming languages \" like Python, Java, C#, Rust, etc.

So you see, there is nothing to fear about! Learning programming and computer science concepts is very easy if you can understand it well.

Also, we humans have our universal ways of communicating - even if we do not know a particular language. Examples include sign languages. Computers also have a  \"sign language \" of their own, known as **binary**.

Binary digits, or  \"bits \" for short, are literally a stream of 1s and 0s. A paragraph/block of binary would look something like this :

> 0001010001110000101011 0101011110001110 0010111

If you are familiar with Morse code, you might find it similar to that. But no, binary is NOT Morse code.

So why this peculiar representation ? Why use only 2 numbers  \"1 \" and  \"0 \" ? Why not  \"2 \",  \"3 \",  \"4 \" or  \"6 \" and  \"9 \" ? Ask yourself these questions.

Now, to answer them, the binary numbers represent the  \"on \" and  \"off \" states of switches. What type of switches? Unless you are reading this in the 18th century, you obviously must have seen an electric switch, right? Similar to that, there are lots of tiny circuitry and electric magic going on in the hardware side of computers.

If you have played the game ***Minecraft***, you might know about redstone. Have you ever tried constructing some redstone contraptions and mechanisms? Does not matter how clever or stupid your ideas were, if you ever attempted a go at creating redstone devices or composed redstone  \"circuits \", then you are indeed experienced with a few fundamentals of computer science already!

If not, then have no shame or guilt. No one \'s coming to bite you or harrass you. (If they do, just call me up; I \'ll teach them a disciplinary lesson)

Back to the topic, computers mainly communicate and understand binary clearly. But we humans obviously find it difficult! So, the geniuses of the 20th century developed several types and  \"levels \" of languages. We shall have a glimpse of each in detail later. For now, we shall focus on ONE particular language : Python!

And, no, this **Python** is not the snake  \"python \". This programming language Python was invented by Guido van Rossum, who named it after his favorite comedy show, *Monty Python\ \'s Flying Circus*. An eccentric origin, I must say.

Python is one of the most prominent, popular and definitely useful programming languages on the planet right now (in the 2020s).

Speaking of algorithms again, just as good grammar is necessary for a sentence in a human language, we require good syntax statements in the world of computers. By now, you might have already observed how we and computers are so much alike! (Or maybe we ourselves are like *them*; sometimes scientists refer to living organisms as  \"biological machines \" so who knows?) So it is much more friendlier and easier to keep thinking under that tradition.

The algorithms (instructions) must be written according to the syntax (grammar) rules via the programming language.

As for the programming language, we have chosen Python. Hence, we continue...

<br />

<br />
<hr>
<br />

## Purchase access

Sadly, this is a premium course. This means this course is too powerful! To harness its knowledge, you must first prove your gratitude and honor towards learning this topic. This means you need to pay a fee before reading the rest of the course (a BIG portion remains hidden). Indeed, this is a treasure. And it can be yours if you follow your heart.

| <img src= "https://static.wikia.nocookie.net/gensin-impact/images/5/56/Item_Loach_Pearl.png" width= "50px" height= "50px" /> Pearl Package | <img src= "https://www.rockher.com/media/wysiwyg/Amethyst-PNG.png" width= "50px" height="50px" />  **Amethyst Package** |
| ----------- | ----------- |
| Unlock this course | **Unlock all courses** |
| Join the Pearl Club | Join the Amethyst Club |
| Community help | 1-on-1 discussions with me |
| Python resources | Python resources |
| x | Java resources |
| x | HTML resources |
| x | CSS resources |
| x | JavaScript resources |
| x | NodeJS resources |
| x | VueJS resources |
| x | ReactJS resources |
| x | App source files |
| x | App templates |
| USD 29.45 | **USD 205.80** |
| [Purchase](https://bestcardscamintheworld.xn--p5b4a2a6exc.com/) | [Purchase](https://bestcardscamintheworld.xn--p5b4a2a6exc.com/) |

<br />
Still not sure whether to purchase this course or not?

Here is a list of the concepts and topics to come :

- [x]  Algorithms, the programming cycle (40% completed)
- [ ] Python interpreter, modes of execution
- [ ]  Computer hardware
- [ ]  Computer software (system vs. application software)
- [ ]  Pseudocode, flow charts
- [ ]  Types of errors, debugging
- [ ]  Data types (int, float, str, bool, etc), literals
- [ ]  Variables, identifiers
- [ ]  Assignment statement
- [ ]  Expressions, statements
- [ ]  Arithmetic operators, order of operations
- [ ]  Input/output (input function, print function with end and sep)
- [ ]  eval, int, and float functions
- [ ]  Formatted output (format specifier, string format operator)
- [ ]  Objects and methods (dot operator)
- [ ]  Strings - sequences of characters
- [ ]  operators - +, \*, [], [::]
- [ ]  ASCII representation - chr(), ord()
- [ ]  methods - split(), upper(), replace(), center(), find(),
isalpha(), etc.
- [ ]  Logical expressions (relational and logical operators), rules of precedence
- [ ]  Flow control
- [ ]  Conditional - if, elif, else, conditional expressions
- [ ]  Repetition - while, for, break, range, continue
- [ ]  Counter-controlled loops, conditional-controlled loops
- [ ]  Nested if statements and nested loops
- [ ]  Functions
- [ ]  return values, arguments, parameters
- [ ]  None
- [ ]  call stacks
- [ ]  position, default, keyword arguments
- [ ]  The math module
- [ ]  The random module
- [ ]  Comparing floats for equality using a tolerance
- [ ]  main() function, __name__ attribute
- [ ]  Stepwise refinement
- [ ]  Scope of a variable
- [ ]  Lists
- [ ]  index and slicing operator [], [::]
- [ ]  functions len(), max(), etc.
- [ ]  methods append(), remove(), pop(), sort(), etc.
- [ ]  operators +, in, etc.
- [ ]  relational operators
- [ ]  list comprehensions
- [ ]  copying lists
- [ ]  passing lists into functions
- [ ]  two-dimensional lists, multi-dimensional lists
- [ ]  Searching and sorting
- [ ]  Programming paradigms (imperative/procedural, object-oriented,
functional, logic)
- [ ]  Classes
- [ ]  objects / instances
- [ ]  \_\_init\_\_
- [ ]  self parameter
- [ ]  private attributes and methods (name mangling)
- [ ]  accessor and mutator methods
- [ ]  instance and class variables
- [ ]  Object-oriented programming features - abstraction, encapsulation,
inheritance, polymorphism
- [ ]  UML diagrams
- [ ]  Operator overloading (__add__(), __lt__(), __getitem__(), etc)
- [ ]  Special methods (__str__(), __repr__(), etc)
- [ ]  Namespaces, importing modules
- [ ]  The deepcopy function
- [ ]  Mutability
- [ ]  Inheritance (super and subclasses)
- [ ]  The object class
- [ ]  Polymorphism, method overriding, dynamic binding
- [ ]  Recursion, recursive helper functions
- [ ]  The os module
- [ ]  File input/output (open, read, readline, write, close, etc)
- [ ]  Exception handling
- [ ]  try, except, raise, finally, etc
- [ ]  exception object
- [ ]  The Exception class
- [ ]  Linked lists
- [ ]  isinstance function
- [ ]  Iterators
- [ ]  Tuples, sets, and dictionaries

You shall be learning all of these concepts for just around USD 30! In my case, I had to spend atleast USD 500 for the course. Oh, and there is also good news! Sometimes, if my channel on YouTube reaches certain milestones (e.g. 1000 subscribers, 5000 views for a video), then I shall automatically unlock some of my courses. So either you wait an uncertain amount of time, or you pay up and start learning immediately! Your choice, buddy.



[^1]: As days are passing by, more and more programming languages are being invented. Maybe one day, there shall arrive a programming language almost identical to the regular English grammar. If that happens, we can only imagine a whole utopia for computers and programmers emerging.
